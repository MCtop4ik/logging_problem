Алгоритм
1. Программа читает текстовый файл построчно, одновременно отслеживая количество строк.
2. Пока файл не достиг 100 строк, каждая строка добавляется в список начальных строк.
3. Когда прочитано больше 100 строк, программа начинает сохранять только последние 100 строк, динамически обновляя их в специальной структуре данных.
4. Программа записывает первые 100 строк в выходной файл, затем добавляет разделитель, обозначающий пропуск текста, и после него — последние 100 строк в том порядке, в котором они встречаются в исходном файле.

Пояснения, начнем с очевидного list, а именно связанный спис как структура данных не состоятельна в процессе экономии памяти. Поэтому в своем решении я использовал массив numpy (встроенный модуль array плох, тем что он не может хранить).
Во-вторых, может появиться идея кодировать информацию через Фано, Хаффмана или даже что-то из семейства Лемпеля — Зива — Велча (см приложение 2, потому что это, на мой взгляд, продвинутый алгоритм, о котором не так много знают в массах, но пользуются им все, так как это основа Zip-файлов). Но в чем проблема, а это их производительность. Учитывая, что задача состоит в том, чтобы сохранить первые и конечные сто логов, усложнение задачи ввиду применения шифрования, не принесет особого успеха. Чем проще, тем лучше.

Для тестирования данной задачи использовались данные настоящего log-file с production.
Для проверки памяти использовался memory_profiler.

Были проведены эксперименты:
1. Обычный list и срез с него (dummy_solution(Top-3).py)
Execution time: 0.07807493 seconds
Memory usage: 10.828125 MB
2. Алгоритм запоминающий файл построчно, одновременно отслеживая количество строк. Но структура данных все еще list (better_solution(Top-2).py)
Execution time: 0.06555128 seconds
Memory usage: 0.1640625 MB
3. Переход на np.array, с тем же алгоритм (main_solution.py)
Execution time: 0.04790974 seconds
Memory usage: 0.15625 MB

Посмотреть сравнение comparison.py

В будущем, в случае если предоставленное решение в production будет показывать неудовлетворительные результаты, можно рассмотреть 
1. Алгоритмы шифрования данных
2. Написание плагина на более низкоуровневых языках такие как С или Ассемблер(его рассматриваю, т.к. алгоритм реализующий данную задачу, не очень сложный)
3. Временную запись строк в файлы, причем быстродействием мы жертвуем
4. Использование не CPython. К примеру не менее популярный PyPy. Статью на другие прикладываю в приложении 3. 

Приложения
1. О структурах данных https://habr.com/ru/articles/339656/
2. Алгоритм Лемпеля — Зива — Велча https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_LZW
3. Почему существует так много Питонов? https://www.toptal.com/python/pochemu-sushchestvuet-tak-mnogo-pitonov
